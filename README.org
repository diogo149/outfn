* outfn
A macro for simpler, more declarative functions.

Naming, meaning, and validation shouldn't be separated. Doing so hurts readability and encourages subtle bugs (confusing a variable for a different one because the name is the same) and boilerplace (validating the same name the same way in different places).

By creating a glossary or "concept map", we create a central place for understanding the types of data passing through a system, their meaining, and their names. Forcing you to think about and create this then allows more declarative programming, by implicitly calling these functions leading to simpler, less coupled logic.

Let's avoid using the same name to refer to different things and enjoy simpler programming.
** Features
*** vanilla/base outfn
- keyword arguments for clarity of function arguments
- function dispatch by argument instead of arity
- decomplecting order from function arguments
  - TODO show threading macro example
- 0-overhead function dispatch based on keys
- macroexpand-time validation that a function is called properly
*** :glossary
- ensures consistent naming which encourages thinking more about names
- DRY validation
*** :implicits
- declarative programming
- solves the "big let" problem by breaking the problem down into domain-level concepts
- could allow for optimizations in the future with batching (group together db calls), parallelization (evaluating the DAG of function calls), or intelligently picking the lowest cost route from the input to the desired data (assigning costs to each function and automatically switching over to a more efficient query)
- easier debugging
- solves the problem of dependency passing (normal solutions involve explicitly declaring dependencies of all your dependencies or passing an opaque options map or using dynamic vars; parameters are coupled either way)
  - eg. x calls y
    - former:
      - the arguments of x contain the arguments of y
      - when changing the logic of y, also have to change x
    - later:
      - the arguments of x contains some map containing the arguments of y
      - in order to understand how x is called, you need to understand y
- macroexpand-time validation of implicits to make sure all the data that is needed is available before the system is running
- auto-testing : by having multiple ways to solve for the same thing, a test suite can be automatically run to make sure each way returns the same result
  - TODO
* TODO
- implement implicits
- more tests
- prismatic schema validation
- usage examples for each feature
- add metadata to each subfunction
  - eg. cost to have implicits find the lowest cost route to get an answer
- add non-macro version
  - for clojurescript compatibility
- better name
* TODO implicits
- problem: how to find the optimal set of calls
  - there is an exponential number of states relative to the number of concepts
    - each concept is either present or not
  - the caching problem: local suboptimal routes may be part of a global optimal route because the intermediates may be shared
- resources
  - [[https://github.com/aysylu/loom][loom]]
  - [[https://github.com/aysylu/loom/blob/master/src/loom/graph.clj][loom/graph.clj]]
  - [[http://mvnrepository.com/artifact/org.optaplanner][maven optaplanner]]
  - [[https://github.com/droolsjbpm/optaplanner][optaplanner github]]
  - [[http://www.optaplanner.org/learn/documentation.html][optaplanner docs]]
