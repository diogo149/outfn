* outfn
A macro for simpler, more declarative functions.
** Features
*** vanilla/base outfn
- keyword arguments for clarity of function arguments
  #+BEGIN_SRC clojure
    (outfn :user-map x :password-list y)
  #+END_SRC
- function dispatch by argument instead of arity
  #+BEGIN_SRC clojure
    (defoutfn outfn
      "what's up doc"
      ([x] (clojure.string/join (repeat x "x")))
      ([y] (clojure.string/join (repeat y "y"))))

    (outfn :x 2) ;; "xx"
    (outfn :y 3) ;; "yyy"
  #+END_SRC
- decomplecting order from function arguments
  #+BEGIN_SRC clojure
    (defoutfn map-v2.0
      "Like map, but better"
      [f coll]
      (map f coll))

    (->> 5
         range
         (map-v2.0 :f inc :coll)) ;; (1 2 3 4 5)

    (->> 5
         (partial +)
         (map-v2.0 :coll (range 5) :f)) ;; (5 6 7 8 9)
  #+END_SRC
- 0-overhead function dispatch based on keys
  - No intermediate maps are made.
  - All the work is done at macroexpand-time.
  - Positional argument function calls are generated.
- macroexpand-time validation that a function is called properly - no waiting for unlucky input needed
  #+BEGIN_SRC clojure
    (defoutfn outfn
      "what's up doc"
      [foo]
      :foo)

    (when nil
      (outfn :fo 2))
    ;; Error!  Invalid set of keys #{:fo} for #'outfn.core/outfn
  #+END_SRC
*** Glossary
Naming, meaning, and validation shouldn't be separated. Doing so hurts readability and encourages subtle bugs (confusing a variable for a different one because the name is the same) and boilerplace (validating the same name the same way in different places). Let's avoid using the same name to refer to different things and enjoy simpler programming.

- encourages consistent naming which encourages thinking more about names
- DRY validation
*** Implicits
By creating a glossary or "concept map", we create a central place for understanding the types of data passing through a system, their meaining, and their names. Forcing you to think about and create this then allows more declarative programming, by implicitly calling these functions leading to simpler, less coupled logic.

- declarative programming
  - TODO show lazy example
- solves the "big let" problem by breaking the problem down into domain-level concepts
- could allow for optimizations in the future with batching (group together db calls), parallelization (evaluating the DAG of function calls), or intelligently picking the lowest cost route from the input to the desired data (assigning costs to each function and automatically switching over to a more efficient query)
- easier debugging
- solves the problem of dependency passing (normal solutions involve explicitly declaring dependencies of all your dependencies or passing an opaque options map or using dynamic vars; parameters are coupled either way)
  - eg. x calls y
    - former:
      - the arguments of x contain the arguments of y
      - when changing the logic of y, also have to change x
    - later:
      - the arguments of x contains some map containing the arguments of y
      - in order to understand how x is called, you need to understand y
- macroexpand-time validation of implicits to make sure all the data that is needed is available before the system is running
- auto-testing : by having multiple ways to solve for the same thing, a test suite can be automatically run to make sure each way returns the same result
  - TODO
** Development
To run tests, perform ~lein midje~ or ~lein midje :autotest~ for the command line.
** TODOs
- common data validation
  - if contains :implicits, must contain :output
- validate output as well
- more tests / docs
- go through all the code TODOs for low hanging fruit, add the rest here
- prismatic schema validation
- implicits improvements
  - auto add try-catch for implicits with nice error handling
  - function to generate visualize call graph (w/ loom)
  - prismatic graph for parallel evaluation
- usage examples for each feature
- figure out how to add cost
  - should each subfunction have its own cost
    - add metadata to each subfunction
      - eg. cost to have implicits find the lowest cost route to get an answer
  - should the toplevel outfn have a cost
- add non-macro version
  - for clojurescript compatibility
- better name
- use something like defnk to make validation DRY
- better implicits algorithm
  - problem: how to find the optimal set of calls
    - there is an exponential number of states relative to the number of concepts
      - each concept is either present or not
    - the caching problem: local suboptimal routes may be part of a global optimal route because the intermediates may be shared
  - resources
    - [[http://mvnrepository.com/artifact/org.optaplanner][maven optaplanner]]
    - [[https://github.com/droolsjbpm/optaplanner][optaplanner github]]
    - [[http://www.optaplanner.org/learn/documentation.html][optaplanner docs]]
** Won't-s
- make both docstring and params optional
  - because there can be ambiguity between the params and the functions
