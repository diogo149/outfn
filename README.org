* outfn
A macro for simpler, more declarative functions.
** Features
*** vanilla/base outfn
- keyword arguments for clarity of function arguments
  #+BEGIN_SRC clojure
    (do-something :user-map x :password-list y)
  #+END_SRC
- function dispatch by argument instead of arity
  #+BEGIN_SRC clojure
    (defoutfn outfn
      "what's up doc"
      ([x] (clojure.string/join (repeat x "x")))
      ([y] (clojure.string/join (repeat y "y"))))

    (outfn :x 2) ;; "xx"
    (outfn :y 3) ;; "yyy"
  #+END_SRC
- decomplecting order from function arguments
  #+BEGIN_SRC clojure
    (defoutfn map-v2.0
      "Like map, but better"
      [f coll]
      (map f coll))

    (->> 5
         range
         (map-v2.0 :f inc :coll)) ;; (1 2 3 4 5)

    (->> 5
         (partial +)
         (map-v2.0 :coll (range 5) :f)) ;; (5 6 7 8 9)
  #+END_SRC
- 0-overhead function dispatch based on keys
  - No intermediate maps are made.
  - All the work is done at macroexpand-time.
  - Positional argument function calls are generated.
- macroexpand-time validation that a function is called properly - no waiting for (un)lucky input at runtime needed
  #+BEGIN_SRC clojure
    (defoutfn outfn
      "what's up doc"
      [foo]
      :foo)

    (when nil
      ;; this doesn't get run
      (outfn :fo 2))
    ;; Error!  Invalid set of keys #{:fo} for #'outfn.core/outfn
  #+END_SRC
*** Glossary
Naming, meaning, and validation shouldn't be separated. Doing so hurts readability and encourages subtle bugs (confusing a variable for a different one because the name is the same) and boilerplace (validating the same name the same way in different places). Let's avoid using the same name to refer to different things and enjoy simpler programming.

- DRY, non-intrusive validation
  #+BEGIN_SRC clojure
    ;; all the validation in one place!
    (def a-glossary {:foo {:validator #(= :foo %)}
                     :choo {:schema {:a {:b s/Int}}}})

    (defoutfn outfn1 {:glossary a-glossary}
      "Some outfn"
      ([foo] 3.5)
      ([choo] :lochness))

    (defoutfn outfn2 {:glossary a-glossary}
      "Some outfn"
      ([foo] :hello)
      ([choo] :world))

    (outfn1 :foo :foo) ;; => 3.5
    (outfn1 :foo 42) ;; => Error!
    (outfn1 :choo {:a {:b 3}}) ;; => :lochness
    (outfn1 :choo {:a {:b "3"}}) ;; => Error!
    (outfn2 :foo :foo) ;; => :hello
    (outfn2 :foo :bar) ;; => Error!
    (outfn2 :choo {:a {:b 3}}) ;; => :world
    (outfn2 :choo {:a {:b "3"}}) ;; => Error!
  #+END_SRC
- encourages consistent naming which encourages thinking more about names (due to the centralized validation based on naming)
*** Implicits
By creating a glossary or "concept map", we create a central place for understanding the types of data passing through a system, their meaining, and their names. Forcing you to think about and create this then allows more declarative programming, by implicitly calling these functions leading to simpler, less coupled logic.

- declarative programming
  #+BEGIN_SRC clojure
    (defoutfn foo-fn {:output :foo}
      "Docstring"
      ([a] 3)
      ([b] 4)
      ([c d] 5))

    (defoutfn bar-fn {:output :bar
                      :implicits #{#'foo-fn}}
      "what's up doc"
      [foo] foo)

    ;; Look ma, no glue code
    (bar-fn :foo 2) ;; 2
    (bar-fn :a nil) ;; 3
    (bar-fn :b 42) ;; 4
    (bar-fn :c 11 :d 22) ;; 5

    ;; I don't need to know what bar-fn needs - decoupling
    (bar-fn :foo 2 :a 3 :b 4 :c 5 :d 6 :q 72) ;; 2

    ;; Laziness is a virtue
    (bar-fn :foo 42 :a (throw Exception.)) ;; 42
  #+END_SRC
- macroexpand-time validation of implicits
  #+BEGIN_SRC clojure
    (when nil
      ;; I don't run
      (bar-fn :q 11)) ;; ERROR
  #+END_SRC
- solves the "big let" problem by breaking the problem down into domain-level concepts
- solves the problem of dependency passing (normal solutions involve explicitly declaring dependencies of all your dependencies or passing an opaque options map or using dynamic vars; parameters are coupled either way)
  - eg. x calls y
    - former:
      - the arguments of x contain the arguments of y
      - when changing the logic of y, also have to change x
    - later:
      - the arguments of x contains some map containing the arguments of y
      - in order to understand how x is called, you need to understand y
**** Potential Benefits
- could allow for optimizations in the future with batching (group together db calls), parallelization (evaluating the DAG of function calls), or intelligently picking the lowest cost route from the input to the desired data (assigning costs to each function and automatically switching over to a more efficient query)
- auto-testing : by having multiple ways to solve for the same thing, a test suite can be automatically run to make sure each way returns the same result
  - TODO
- easier debugging
  - TODO try-catch can be automatically generated, and all the relevant information can be thrown on an exception
** Development
To run tests, perform ~lein midje~ or ~lein midje :autotest~ for the command line.
** TODOs
- finish implicits readme
- fix big let block test
- common-data-map validation
  - if contains :implicits, must contain :output
- validate output when :output param is given
- more tests / docs
- go through all the code TODOs for low hanging fruit, add the rest here
- implicits improvements
  - auto add try-catch for implicits with nice error handling
  - function to generate visualize call graph (w/ loom)
  - prismatic graph for parallel evaluation
- figure out how to add cost
  - should each subfunction have its own cost
    - add metadata to each subfunction
      - eg. cost to have implicits find the lowest cost route to get an answer
  - should the toplevel outfn have a cost
- add non-macro version
  - for clojurescript compatibility
- better name (maybe?)
- use something like defnk to make validation DRY
- consider implicit transitivity (can call implicits of functions that can be called implicitly)
- better implicits algorithm
  - problem: how to find the optimal set of calls
    - there is an exponential number of states relative to the number of concepts
      - each concept is either present or not
    - the caching problem: local suboptimal routes may be part of a global optimal route because the intermediates may be shared
  - resources
    - [[http://mvnrepository.com/artifact/org.optaplanner][maven optaplanner]]
    - [[https://github.com/droolsjbpm/optaplanner][optaplanner github]]
    - [[http://www.optaplanner.org/learn/documentation.html][optaplanner docs]]
** Won't-s
- make both docstring and params optional
  - because there can be ambiguity between the params and the functions
